<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ListenType</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Radio+Canada+Big:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Radio Canada Big', sans-serif;
        }
        /* Custom styles for audio seek bar */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #000000; /* Changed from blue-500 to black */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #000000; /* Changed from blue-500 to black */
            border-radius: 50%;
            cursor: pointer;
        }
        /* Style for gap input fields */
        .gap-input {
            border-bottom: 1px solid #9CA3AF; /* gray-400 */
            text-align: center;
            padding-left: 0.25rem;
            padding-right: 0.25rem;
            margin-left: 0.25rem;
            margin-right: 0.25rem;
            outline: none;
        }
        .gap-input:focus {
            border-color: #000000; /* Changed from blue-500 to black */
        }
        /* Spinner animation for processing screen */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
            border: 4px solid #f3f3f3; /* Light grey base */
            border-top: 4px solid #000000; /* Black for the spinning part */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            box-sizing: border-box; /* Ensures padding/border don't affect size */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="main-card" class="bg-white rounded-2xl shadow-xl p-8 w-full relative overflow-hidden max-w-2xl">

        <!-- Input Screen Content -->
        <div id="input-screen">
            <h1 class="text-3xl font-bold text-gray-800 mb-4 flex items-center">
                <span role="img" aria-label="waving hand" class="mr-2 text-4xl">ðŸ‘‹</span>
                Welcome to ListenType!
            </h1>

            <p class="text-lg text-gray-700 mb-6">
                Improve your English by listening to audio and filling in the gaps.
            </p>
            <p class="text-lg text-gray-700 mb-4">
                To get started, simply paste your transcript here:
            </p>

            <textarea id="transcript-textarea"
                class="w-full h-40 p-4 mb-6 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-black text-base resize-y"
            ></textarea>

            <p class="text-lg text-gray-700 mb-6">
                Or even upload your audio track if you want.
            </p>

            <div class="flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
                <label for="audio-upload" id="upload-audio-label" class="flex items-center justify-center px-6 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 w-full sm:w-auto cursor-pointer">
                    <!-- Reference to icons/upload.svg -->
                    <img src="icons/upload.svg" class="h-5 w-5 mr-2" alt="Upload audio icon" onerror="this.onerror=null;this.src='https://placehold.co/20x20/cccccc/222222?text=Up'">
                    Upload audio
                </label>
                <input id="audio-upload" type="file" accept="audio/*" class="hidden" />

                <button id="start-button" disabled
                    class="flex items-center justify-center px-6 py-3 rounded-lg w-full sm:w-auto bg-gray-300 text-gray-500 cursor-not-allowed">
                    Let's start!
                    <!-- Reference to icons/arrow-right.svg -->
                    <img src="icons/arrow-right.svg" class="h-5 w-5 ml-2" alt="Start icon" onerror="this.onerror=null;this.src='https://placehold.co/20x20/cccccc/222222?text=Go'">
                </button>
            </div>
        </div>

        <!-- Processing Screen Content -->
        <div id="processing-screen" class="hidden">
            <div class="text-center flex flex-col items-center justify-center h-full py-8">
                <!-- Spinner (CSS animated, not an SVG file) -->
                <div class="spinner mb-4"></div>
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Processing your transcript</h2>
                <p class="text-lg text-gray-700 mb-6">This should take less than a minute.</p>
                <button id="cancel-button" class="px-6 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">
                    Cancel
                </button>
            </div>
        </div>

        <!-- Gap Filling Test Content -->
        <div id="test-screen" class="hidden p-8 pb-20 relative">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Transcript</h2>
            <div id="transcript-display" class="text-lg text-gray-700 leading-relaxed mb-8">
                <!-- Gaps will be rendered here by JavaScript -->
            </div>

            <!-- Floating Audio Player and Finish Button Container -->
            <div class="fixed bottom-4 left-1/2 -translate-x-1/2 flex items-end space-x-4 z-10">
                <!-- Floating Audio Player -->
                <div id="audio-player-container" class="bg-white rounded-[16px] shadow-md p-4 flex items-center space-x-4 hidden">
                    <audio id="audio-element" preload="metadata"></audio>
                    <button id="play-pause-button" class="text-gray-700 hover:text-black focus:outline-none">
                        <!-- Reference to icons/play.svg -->
                        <img id="play-icon" src="icons/play.svg" class="h-8 w-8" alt="Play icon" onerror="this.onerror=null;this.src='https://placehold.co/32x32/cccccc/222222?text=Pl'">
                        <!-- Reference to icons/pause.svg -->
                        <img id="pause-icon" src="icons/pause.svg" class="h-8 w-8 hidden" alt="Pause icon" onerror="this.onerror=null;this.src='https://placehold.co/32x32/cccccc/222222?text=Pa'">
                    </button>
                    <input type="range" id="seek-bar" min="0" value="0" class="w-48 h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer" />
                    <div id="time-display" class="text-sm text-gray-600">0:00 / 0:00</div>
                </div>

                <!-- Floating Finish Button (now a check icon) -->
                <div id="finish-button-container" class="hidden">
                    <button id="finish-button" class="p-3 bg-black text-white rounded-[16px] shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-black">
                        <!-- Reference to icons/check-black.svg -->
                        <img src="icons/check-black.svg" class="h-8 w-8" alt="Finish icon" onerror="this.onerror=null;this.src='https://placehold.co/32x32/cccccc/222222?text=OK'">
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // DOM Elements
        const mainCard = document.getElementById('main-card');
        const inputScreen = document.getElementById('input-screen');
        const processingScreen = document.getElementById('processing-screen');
        const testScreen = document.getElementById('test-screen');
        const transcriptTextarea = document.getElementById('transcript-textarea');
        const uploadAudioLabel = document.getElementById('upload-audio-label');
        const audioUploadInput = document.getElementById('audio-upload');
        const startButton = document.getElementById('start-button');
        const cancelButton = document.getElementById('cancel-button');
        const transcriptDisplay = document.getElementById('transcript-display');
        const audioPlayerContainer = document.getElementById('audio-player-container');
        const audioEl = document.getElementById('audio-element');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon'); // Now an img element
        const pauseIcon = document.getElementById('pause-icon'); // Now an img element
        const seekBar = document.getElementById('seek-bar');
        const timeDisplay = document.getElementById('time-display');
        const finishButtonContainer = document.getElementById('finish-button-container');
        const finishButton = document.getElementById('finish-button');

        // Application State
        let transcriptText = '';
        let uploadedAudioFile = null;
        let uploadedAudioFileName = null;
        let currentPage = 'input'; // 'input', 'processing', 'test'
        let processedTranscript = '';
        let extractedAdvancedWords = [];
        let userAnswers = [];
        let correctAnswers = [];
        let isPlaying = false;

        // --- Utility Functions ---
        function updateUI() {
            // Update main card width
            if (currentPage === 'input') {
                mainCard.classList.remove('max-w-lg', 'max-w-4xl');
                mainCard.classList.add('max-w-2xl');
            } else if (currentPage === 'processing') {
                mainCard.classList.remove('max-w-2xl', 'max-w-4xl');
                mainCard.classList.add('max-w-lg');
            } else if (currentPage === 'test') {
                mainCard.classList.remove('max-w-2xl', 'max-w-lg');
                mainCard.classList.add('max-w-4xl');
            }

            // Show/hide screens
            inputScreen.classList.toggle('hidden', currentPage !== 'input');
            processingScreen.classList.toggle('hidden', currentPage !== 'processing');
            testScreen.classList.toggle('hidden', currentPage !== 'test');

            // Show/hide floating elements (controlled by the new parent container)
            const floatingControlsContainer = document.querySelector('.fixed.bottom-4.left-1\\/2');
            if (currentPage === 'test') {
                floatingControlsContainer.classList.remove('hidden');
                audioPlayerContainer.classList.toggle('hidden', !uploadedAudioFile);
                finishButtonContainer.classList.remove('hidden');
            } else {
                floatingControlsContainer.classList.add('hidden');
            }
        }

        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // --- Event Handlers ---

        transcriptTextarea.addEventListener('input', (e) => {
            transcriptText = e.target.value;
            startButton.disabled = transcriptText.trim().length === 0;
            if (startButton.disabled) {
                startButton.classList.remove('bg-black', 'hover:bg-gray-800', 'text-white');
                startButton.classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
            } else {
                startButton.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                startButton.classList.add('bg-black', 'hover:bg-gray-800', 'text-white');
            }
        });

        audioUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadedAudioFile = file;
                uploadedAudioFileName = file.name;
                uploadAudioLabel.textContent = uploadedAudioFileName;
                console.log('Selected audio file:', file.name);
            } else {
                uploadedAudioFile = null;
                uploadedAudioFileName = null;
                uploadAudioLabel.textContent = 'Upload audio';
            }
        });

        startButton.addEventListener('click', () => {
            currentPage = 'processing';
            updateUI();
            processTranscriptWithGemini();
        });

        cancelButton.addEventListener('click', () => {
            currentPage = 'input';
            updateUI();
            alert('Processing cancelled.');
        });

        playPauseButton.addEventListener('click', () => {
            if (audioEl.paused) {
                audioEl.play();
                isPlaying = true;
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                audioEl.pause();
                isPlaying = false;
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        });

        seekBar.addEventListener('input', (e) => {
            audioEl.currentTime = e.target.value;
        });

        finishButton.addEventListener('click', () => {
            alert('Test Finished! (Functionality to be added)');
            currentPage = 'input';
            transcriptText = '';
            transcriptTextarea.value = '';
            uploadedAudioFile = null;
            uploadedAudioFileName = null;
            uploadAudioLabel.textContent = 'Upload audio';
            processedTranscript = '';
            extractedAdvancedWords = [];
            userAnswers = [];
            correctAnswers = [];
            isPlaying = false;
            if (!audioEl.paused) audioEl.pause();
            audioEl.currentTime = 0;
            updateUI();
        });

        // --- Audio Element Listeners ---
        audioEl.addEventListener('loadedmetadata', () => {
            seekBar.max = audioEl.duration;
            timeDisplay.textContent = `${formatTime(audioEl.currentTime)} / ${formatTime(audioEl.duration)}`;
        });

        audioEl.addEventListener('timeupdate', () => {
            seekBar.value = audioEl.currentTime;
            timeDisplay.textContent = `${formatTime(audioEl.currentTime)} / ${formatTime(audioEl.duration)}`;
        });

        audioEl.addEventListener('ended', () => {
            isPlaying = false;
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        });

        // --- Core Logic Functions ---

        async function processTranscriptWithGemini() {
            try {
                const prompt = `Given the following transcript, identify all advanced English words (e.g., words that might be challenging for an intermediate learner). Return a JSON object with two properties: "advancedWords" (an array of these words) and "modifiedTranscript" (the original transcript with each advanced word replaced by a unique placeholder like "[GAP_WORD_X]", where X is a sequential number starting from 0).

                Example:
                Transcript: "The intricate tapestry of human emotions is a complex phenomenon."
                Response: {
                  "advancedWords": ["intricate", "tapestry", "phenomenon"],
                  "modifiedTranscript": "The [GAP_WORD_0] [GAP_WORD_1] of human emotions is a complex [GAP_WORD_2]."
                }

                Transcript: "${transcriptText}"`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "advancedWords": {
                                    type: "ARRAY",
                                    items: { "type": "STRING" }
                                },
                                "modifiedTranscript": { "type": "STRING" }
                            },
                            propertyOrdering: ["advancedWords", "modifiedTranscript"]
                        }
                    }
                };
                // IMPORTANT: Replace "YOUR_GEMINI_API_KEY_HERE" with your actual Gemini API key.
                // You can get one from Google AI Studio: https://aistudio.google.com/
                const apiKey = "AIzaSyB260YVe4DKDCFH_Oj69Xq0JBryM8Du2SM";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const json = result.candidates[0].content.parts[0].text;
                    const parsedResult = JSON.parse(json);

                    extractedAdvancedWords = parsedResult.advancedWords || [];
                    processedTranscript = parsedResult.modifiedTranscript || transcriptText;
                    userAnswers = Array(extractedAdvancedWords.length).fill('');
                    correctAnswers = Array(extractedAdvancedWords.length).fill(false);

                    setTimeout(() => {
                        currentPage = 'test';
                        updateUI();
                        renderGapFillingTest();
                        if (uploadedAudioFile) {
                            audioEl.src = URL.createObjectURL(uploadedAudioFile);
                            audioEl.load(); // Load audio to get metadata
                        }
                    }, 500); // Small delay before transitioning to test
                } else {
                    console.error('Gemini API response structure unexpected:', result);
                    alert('Error processing transcript. Please try again.');
                    currentPage = 'input';
                    updateUI();
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                alert('Failed to process transcript. Please check your network or try again.');
                currentPage = 'input';
                updateUI();
            }
        }

        function renderGapFillingTest() {
            transcriptDisplay.innerHTML = ''; // Clear previous content
            
            // Step 1: Split the processed transcript by actual newline characters
            const paragraphs = processedTranscript.split('\n');

            paragraphs.forEach(paragraph => {
                // Step 2: For each paragraph, split into sentences, keeping the delimiters
                // This regex splits by . ? ! followed by optional whitespace, and captures the delimiter itself
                const sentenceParts = paragraph.split(/([.?!]\s*)/);

                let currentSentenceText = '';
                sentenceParts.forEach(part => {
                    if (part.match(/[.?!]\s*$/)) { // If this part ends with a sentence delimiter
                        currentSentenceText += part;
                        if (currentSentenceText.trim().length > 0) {
                            // Create a div for this complete sentence
                            const sentenceDiv = document.createElement('div');
                            sentenceDiv.classList.add('mb-3', 'p-2', 'border-b', 'border-gray-200');

                            // Now, populate this sentenceDiv with text and gap inputs
                            const contentParts = currentSentenceText.split(/(\[GAP_WORD_\d+\])/g);
                            contentParts.forEach(contentPart => {
                                if (contentPart.startsWith('[GAP_WORD_') && contentPart.endsWith(']')) {
                                    const gapNumber = parseInt(contentPart.match(/\d+/)[0]);
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.classList.add('gap-input');
                                    const originalWordLength = extractedAdvancedWords[gapNumber] ? extractedAdvancedWords[gapNumber].length : 8;
                                    input.style.width = `${Math.max(80, originalWordLength * 10)}px`;
                                    input.value = userAnswers[gapNumber] || '';
                                    input.dataset.gapIndex = gapNumber;

                                    // No checkmark icon, just change text color
                                    input.addEventListener('input', (e) => {
                                        const index = parseInt(e.target.dataset.gapIndex);
                                        userAnswers[index] = e.target.value;
                                        const isCorrect = e.target.value.toLowerCase() === extractedAdvancedWords[index].toLowerCase();
                                        correctAnswers[index] = isCorrect;
                                        if (isCorrect) {
                                            e.target.classList.add('text-green-500');
                                        } else {
                                            e.target.classList.remove('text-green-500');
                                        }
                                    });

                                    // Apply green color if already correct (on re-render)
                                    if (correctAnswers[gapNumber]) {
                                        input.classList.add('text-green-500');
                                    }

                                    sentenceDiv.appendChild(input); // Append input directly
                                } else {
                                    sentenceDiv.appendChild(document.createTextNode(contentPart));
                                }
                            });
                            transcriptDisplay.appendChild(sentenceDiv);
                        }
                        currentSentenceText = ''; // Reset for next sentence
                    } else {
                        currentSentenceText += part; // Accumulate non-delimiter parts
                    }
                });

                // Handle any remaining text that didn't end with punctuation in a paragraph
                if (currentSentenceText.trim().length > 0) {
                    const sentenceDiv = document.createElement('div');
                    sentenceDiv.classList.add('mb-3', 'p-2', 'border-b', 'border-gray-200');
                    const contentParts = currentSentenceText.split(/(\[GAP_WORD_\d+\])/g);
                    contentParts.forEach(contentPart => {
                        if (contentPart.startsWith('[GAP_WORD_') && contentPart.endsWith(']')) {
                            const gapNumber = parseInt(contentPart.match(/\d+/)[0]);
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.classList.add('gap-input');
                            const originalWordLength = extractedAdvancedWords[gapNumber] ? extractedAdvancedWords[gapNumber].length : 8;
                            input.style.width = `${Math.max(80, originalWordLength * 10)}px`;
                            input.value = userAnswers[gapNumber] || '';
                            input.dataset.gapIndex = gapNumber;

                            // No checkmark icon, just change text color
                            input.addEventListener('input', (e) => {
                                const index = parseInt(e.target.dataset.gapIndex);
                                userAnswers[index] = e.target.value;
                                const isCorrect = e.target.value.toLowerCase() === extractedAdvancedWords[index].toLowerCase();
                                correctAnswers[index] = isCorrect;
                                if (isCorrect) {
                                    e.target.classList.add('text-green-500');
                                } else {
                                    e.target.classList.remove('text-green-500');
                                }
                            });

                            if (correctAnswers[gapNumber]) {
                                input.classList.add('text-green-500');
                            }
                            sentenceDiv.appendChild(input); // Append input directly
                        } else {
                            sentenceDiv.appendChild(document.createTextNode(contentPart));
                        }
                    });
                    transcriptDisplay.appendChild(sentenceDiv);
                }
            });
        }

        // Initial UI update on load
        document.addEventListener('DOMContentLoaded', updateUI);
    </script>
</body>
</html>
